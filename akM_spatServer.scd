

// ######################################################
// ################# LANGUAGE-SIDE INIT #################
// ######################################################

//==================== SERVER PARAMETERS ====================

"[INIT] clearing server tree...".post;

ServerTree.removeAll;

" ok.".postln;

"[INIT] server settings...".post;

s = Server.default;

s.options.numBuffers = (2048 * 2048) * 2;
s.options.memSize = 8192 * 128;
s.options.numWireBufs = 2048;
s.options.maxNodes = 1024 * 32;

" ok.".postln;


//==================== GLOBAL SETTINGS ====================

"[INIT] global settings...".post;

~soundSpeedInAir = 344; //[m.s^(-1)]
~numSpeakers = 12;
~numSubs = 2;
~numSourceParameters = 7;
~numEQParameters = 21;
~numSources = 32;
~oscReceivePort = 23446;
~oscSendNetAddr = NetAddr("127.0.0.1",23444);

" ok.".postln;

//==================== AUDIO INTERFACE SETTINGS ====================

"[INIT] audio interface settings...".post;

//s.options.inDevice = "VB-Matrix VASIO-64A";
//s.options.outDevice = "VB-Matrix VASIO-64A";
s.options.device = "JackRouter";
s.options.sampleRate = 48000;

s.options.safetyClipThreshold = 1;

s.options.numOutputBusChannels = ~numSpeakers + ~numSubs;
s.options.numInputBusChannels = ~numSources;

" ok.".postln;

//==================== INITIAL SPEAKERS DEFINITION ====================

"[INIT] initial speakers definition...".post;

//----- SATS -----
~speakers = Array.new(~numSpeakers);

~speakers.add([
	\sat_1_1,
	(
		posX: -2,
		posY: 2,
		posZ: 0.3
	)
]);

~speakers.add([
	\sat_1_2,
	(
		posX: -2,
		posY: 2,
		posZ: 1.7
	)
]);

~speakers.add([
	\sat_1_3,
	(
		posX: -2,
		posY: 2,
		posZ: 3
	)
]);

~speakers.add([
	\sat_2_1,
	(
		posX: 2,
		posY: 2,
		posZ: 0.3
	)
]);

~speakers.add([
	\sat_2_2,
	(
		posX: 2,
		posY: 2,
		posZ: 1.7
	)
]);

~speakers.add([
	\sat_2_3,
	(
		posX: 2,
		posY: 2,
		posZ: 3
	)
]);

~speakers.add([
	\sat_3_1,
	(
		posX: 2,
		posY: -2,
		posZ: 0.3
	)
]);

~speakers.add([
	\sat_3_2,
	(
		posX: 2,
		posY: -2,
		posZ: 1.7
	)
]);

~speakers.add([
	\sat_3_3,
	(
		posX: 2,
		posY: -2,
		posZ: 3
	)
]);

~speakers.add([
	\sat_4_1,
	(
		posX: -2,
		posY: -2,
		posZ: 0.3
	)
]);

~speakers.add([
	\sat_4_2,
	(
		posX: -2,
		posY: -2,
		posZ: 1.7
	)
]);

~speakers.add([
	\sat_4_3,
	(
		posX: -2,
		posY: -2,
		posZ: 3
	)
]);

//----- SUBS -----
~subs = Array.new(~numSubs);

~subs.add([
	\sub_1,
	(
		posX: -1.5,
		posY: -3.5,
		posZ: 0.3
	)
]);

~subs.add([
	\sub_2,
	(
		posX: 1.8,
		posY: 3.5,
		posZ: 0.3
	)
]);

" ok.".postln;

//==================== UTILITY FUNCTIONS ====================

"[INIT] utility functions...".post;

//This function calculates the distance between point A in point B in space
~distance = {
	arg pointA, pointB;
	var vx, vy, vz, d;
	vx = pointB[0] - pointA[0];
	vy = pointB[1] - pointA[1];
	vz = pointB[2] - pointA[2];
	d = (vx.squared + vy.squared + vz.squared).sqrt;
	d;
};

//This function finds the centroid of a list of points in space
~centroid = {
	arg points;
	var sum = points.sum;
	sum / points.size;
};

//This function finds the max distance between the centroid and the speakers
// -> NOT USED AT THE MOMENT
~max_radius = {
	arg points;
	var radiuses, val, index, center = ~centroid.value(points);
	radiuses = points.collect({ |p| ~distance.value([0,0,0],p - center) });
	# val, index = ArrayMax.kr(radiuses);
	val;
};

~dB_to_factor = {
	arg val;
	var result;
	result  = 10.0**(val / 20);
};

" ok.".postln;

//==================== MORE GLOBAL VALUES ====================

"[INIT] more global settings...".post;

~speakersPositions = List.new;
~speakers.do({
	arg spkr;
	~speakersPositions.add([spkr[1].posX,spkr[1].posY,spkr[1].posZ]);
});
~subsPositions = List.new;
~subs.do({
	arg sub;
	~subsPositions.add([sub[1].posX,sub[1].posY,sub[1].posZ]);
});

//TO-DO: fix this so that the values are generated by the speakers config (right now there is pb with Ugens, the values are wrong for max radius when calculated from inside the synth)
//maybe make the max radius an OSC parameter instead?

//~speakersCentroid = ~centroid.value(~speakersPositions);
//~speakersMaxRadius = ~max_radius.value(~speakersPositions);

~speakersCentroid = [0.0,0.0,1.777777];
~speakersMaxRadius = 3.14;

" ok.".postln;



//==================== BUSSES SETUP ====================

"[INIT] clearing bus allocator...".post;

s.newBusAllocators;

" ok.".postln;

"[INIT] allocating busses...".post;


~controlBussesInputs = Dictionary.new;
~controlBussesSpatGains = Dictionary.new;
~controlBussesSpatSubsGains = Dictionary.new;
~controlBussesSpatDelayTimes = Dictionary.new;
~controlBussesSpatSubsDelayTimes = Dictionary.new;
~controlBussesSourcesDistanceAttenuation = Dictionary.new;
~controlBussesSatEQ = Dictionary.new;
~controlBussesSubEQ = Dictionary.new;

~controlBussesReverb = Bus.control(s,2);
~controlBussesSystemGain = Bus.control(s,1);
~controlBussesSatGains = Bus.control(s,~numSpeakers);
~controlBussesSubGains = Bus.control(s,~numSubs);
~controlBussesSatFilter = Bus.control(s,2);
~controlBussesSubFilter = Bus.control(s,2);

~audioBussesSpeakersDry = Bus.audio(s,~numSpeakers);
~audioBussesSpeakersPreFX = Bus.audio(s,~numSpeakers);
~audioBussesSpeakersPostFX = Bus.audio(s,~numSpeakers);

~audioBussesSpeakersEQ = Dictionary.new;

~audioBussesSubsDry = Bus.audio(s,~numSubs);
~audioBussesSubsPreFX = Bus.audio(s,~numSubs);
~audioBussesSubsPostFX = Bus.audio(s,~numSubs);

~audioBussesSubsEQ = Dictionary.new;

(1..~numSources).do({
	arg i;
	var sourceId = ("source"++i).asSymbol;
	~controlBussesInputs[sourceId] = Bus.control(s,~numSourceParameters);
	~controlBussesSpatGains[sourceId] = Bus.control(s,~numSpeakers);
	~controlBussesSpatSubsGains[sourceId] = Bus.control(s,~numSubs);
	~controlBussesSpatDelayTimes[sourceId] = Bus.control(s,~numSpeakers);
	~controlBussesSpatSubsDelayTimes[sourceId] = Bus.control(s,~numSubs);
	~controlBussesSourcesDistanceAttenuation[sourceId] = Bus.control(s,1);
});

(1..~numSpeakers).do({
	arg i;
	var speakerId = ("sat"++i).asSymbol;
	~controlBussesSatEQ[speakerId] = Bus.control(s,~numEQParameters);
	~audioBussesSpeakersEQ[speakerId] = Bus.audio(s,1);
});

(1..~numSubs).do({
	arg i;
	var subId = ("sub"++i).asSymbol;
	~controlBussesSubEQ[subId] = Bus.control(s,~numEQParameters);
	~audioBussesSubsEQ[subId] = Bus.audio(s,1);
});

" ok.".postln;

// ######################################################
// ################## SERVER-SIDE INIT ##################
// ######################################################

"[INIT] booting server...".postln;

s.waitForBoot({

	"[INIT] server booted.".postln;

	"[INIT] clearing any existing synth instances...".post;

	s.freeAll;

	s.sync;

	" ok.".postln;

	//==================== INITIALIZE BUSSES VALUES ====================

	"[INIT] initializing busses values...".post;

	(1..~numSpeakers).do({
		arg i;
		var speakerId = ("sat"++i).asSymbol;

		~controlBussesSatGains.setAt(i-1,1.0);

		//EQ init
		~controlBussesSatEQ[speakerId].setAt(0,0); //EQ - On/Off

		~controlBussesSatEQ[speakerId].setAt(1,0); //LSHLF - On/Off
		~controlBussesSatEQ[speakerId].setAt(2,400); //LSHLF - Freq
		~controlBussesSatEQ[speakerId].setAt(3,0); //LSHLF - Gain
		~controlBussesSatEQ[speakerId].setAt(4,1); //LSHLF - RS

		~controlBussesSatEQ[speakerId].setAt(5,0); //PK1 - On/Off
		~controlBussesSatEQ[speakerId].setAt(6,2000); //PK1 - Freq
		~controlBussesSatEQ[speakerId].setAt(7,0); //PK1 - Gain
		~controlBussesSatEQ[speakerId].setAt(8,1); //PK1 - RQ

		~controlBussesSatEQ[speakerId].setAt(9,0); //PK2 - On/Off
		~controlBussesSatEQ[speakerId].setAt(10,6000); //PK2 - Freq
		~controlBussesSatEQ[speakerId].setAt(11,0); //PK2 - Gain
		~controlBussesSatEQ[speakerId].setAt(12,1); //PK2 - RQ

		~controlBussesSatEQ[speakerId].setAt(13,0); //PK3 - On/Off
		~controlBussesSatEQ[speakerId].setAt(14,12000); //PK3 - Freq
		~controlBussesSatEQ[speakerId].setAt(15,0); //PK3 - Gain
		~controlBussesSatEQ[speakerId].setAt(16,1); //PK3 - RQ

		~controlBussesSatEQ[speakerId].setAt(17,0); //HSHLF - On/Off
		~controlBussesSatEQ[speakerId].setAt(18,16000); //HSHLF - Freq
		~controlBussesSatEQ[speakerId].setAt(19,0); //HSHLF - Gain
		~controlBussesSatEQ[speakerId].setAt(20,1); //HSHLF - RS
	});

	(1..~numSubs).do({
		arg i;
		var subId = ("sub"++i).asSymbol;

		~controlBussesSubGains.setAt(i-1,1.0);

		//EQ init
		~controlBussesSubEQ[subId].setAt(0,0); //EQ - On/Off

		~controlBussesSubEQ[subId].setAt(1,0); //LSHLF - On/Off
		~controlBussesSubEQ[subId].setAt(2,400); //LSHLF - Freq
		~controlBussesSubEQ[subId].setAt(3,0); //LSHLF - Gain
		~controlBussesSubEQ[subId].setAt(4,1); //LSHLF - RS

		~controlBussesSubEQ[subId].setAt(5,0); //PK1 - On/Off
		~controlBussesSubEQ[subId].setAt(6,2000); //PK1 - Freq
		~controlBussesSubEQ[subId].setAt(7,0); //PK1 - Gain
		~controlBussesSubEQ[subId].setAt(8,1); //PK1 - RQ

		~controlBussesSubEQ[subId].setAt(9,0); //PK2 - On/Off
		~controlBussesSubEQ[subId].setAt(10,6000); //PK2 - Freq
		~controlBussesSubEQ[subId].setAt(11,0); //PK2 - Gain
		~controlBussesSubEQ[subId].setAt(12,1); //PK2 - RQ

		~controlBussesSubEQ[subId].setAt(13,0); //PK3 - On/Off
		~controlBussesSubEQ[subId].setAt(14,12000); //PK3 - Freq
		~controlBussesSubEQ[subId].setAt(15,0); //PK3 - Gain
		~controlBussesSubEQ[subId].setAt(16,1); //PK3 - RQ

		~controlBussesSubEQ[subId].setAt(17,0); //HSHLF - On/Off
		~controlBussesSubEQ[subId].setAt(18,16000); //HSHLF - Freq
		~controlBussesSubEQ[subId].setAt(19,0); //HSHLF - Gain
		~controlBussesSubEQ[subId].setAt(20,1); //HSHLF - RS
	});

	~controlBussesSystemGain.setAt(0,1.0);

	~controlBussesSatFilter.setAt(0,120);
	~controlBussesSatFilter.setAt(1,1.0);
	~controlBussesSubFilter.setAt(0,90);
	~controlBussesSubFilter.setAt(1,1.0);

	" ok.".postln;


	//==================== SYNTH DEFINITIONS ====================

	"[INIT] adding sources spat panner synth definitions...".post;

	//First, we make a SynthDef that will only work on control busses, taking as inputs the source parameters and outputing the gains for each speaker. We also compute the delays based on the distance
	(1..~numSources).do({

		arg sourceIndex;
		SynthDef.new(("spatPannerSource"++sourceIndex).asSymbol,{
			var outputGains, outputDelays, outputSubsGains, outputSubsDelays, sourceId, inputParams, sourcePosX, sourcePosY, sourcePosZ, sourceRadius, a, alpha, sourcePos, speakersDistancesToSource, subsDistancesToSource, calculatedSpeakersGains, calculatedSubsGains, sumTerm, sumTermSubs, index, delayLevel, center, maxRadius, distToCenter, distToHull, distanceAttenuationFactor, p, q;

			sourceId = ("source"++sourceIndex).asSymbol;

			//retrieving the source parameters from the dedicated control busses
			inputParams = In.kr(~controlBussesInputs[sourceId],~numSourceParameters);
			sourcePosX = inputParams[0];
			sourcePosY = inputParams[1];
			sourcePosZ = inputParams[2];
			sourceRadius = inputParams[3];
			a = inputParams[4];
			delayLevel = inputParams[5];

			sourcePos = [sourcePosX, sourcePosY, sourcePosZ];

			//we make a list containing the distance to the source from each speaker

			//sats
			speakersDistancesToSource = List.new;
			~speakers.do{
				arg spkrData;
				var spkrPos, distanceToSource;

				spkrPos = [spkrData[1].posX, spkrData[1].posY, spkrData[1].posZ];
				distanceToSource = ~distance.value(spkrPos,sourcePos) + 0.00001; //0 division safe by adding small float

				speakersDistancesToSource.add(distanceToSource);
			};
			//subs
			subsDistancesToSource = List.new;
			~subs.do{
				arg spkrData;
				var spkrPos, distanceToSource;

				spkrPos = [spkrData[1].posX, spkrData[1].posY, spkrData[1].posZ];
				distanceToSource = ~distance.value(spkrPos,sourcePos) + 0.00001; //0 division safe by adding small float

				subsDistancesToSource.add(distanceToSource);
			};

			//calculating the sum term common to all selected speakers gains

			//sats
			sumTerm = 0.0;
			speakersDistancesToSource.do({
				arg currDistance;
				sumTerm = sumTerm + (1 / currDistance.squared.pow(a));
			});

			sumTerm = (1 / sumTerm.sqrt);

			//subs
			sumTermSubs = 0.0;
			subsDistancesToSource.do({
				arg currDistance;
				sumTermSubs = sumTermSubs + (1 / currDistance.squared.pow(a));
			});

			sumTermSubs = (1 / sumTermSubs.sqrt);

			//now we calculate the gain for each speaker (we have not yet filtered the gains by the source radius)

			//sats
			calculatedSpeakersGains = List.new;
			speakersDistancesToSource.do({
				arg currDistance;
				calculatedSpeakersGains.add((1 / currDistance.pow(a)) * sumTerm);
			});
			//subs
			calculatedSubsGains = List.new;
			subsDistancesToSource.do({
				arg currDistance;
				calculatedSubsGains.add((1 / currDistance.pow(a)) * sumTermSubs);
			});


			//we can finally output the final speaker gains: if the speaker is outside of the source radius, the gain gets multiplied by zero. We also calculate the distance delays in this this loop.

			//sats
			index = 0;
			outputGains = Array.fill(~speakers.size, {arg i; 0});
			outputDelays = Array.fill(~speakers.size, {arg i; 0});
			outputGains.size.do({
				var dist = speakersDistancesToSource[index];

				outputGains[index] = calculatedSpeakersGains[index] * (dist < sourceRadius);
				outputDelays[index] = (dist / ~soundSpeedInAir) * delayLevel; //delay is the time for the sound from the source to reach the speaker, multiplied by user parameter 'delayLevel' (received over OSC)

				index = index+1;
			});
			//subs
			index = 0;
			outputSubsGains = Array.fill(~subs.size, {arg i; 0});
			outputSubsDelays = Array.fill(~subs.size, {arg i; 0});
			outputSubsGains.size.do({
				var dist = subsDistancesToSource[index];

				outputSubsGains[index] = calculatedSubsGains[index] * (dist < sourceRadius);
				outputSubsDelays[index] = (dist / ~soundSpeedInAir) * delayLevel;

				index = index+1;
			});


			//we output the speakers delays to the dedicated control bus
			Out.kr(~controlBussesSpatDelayTimes[sourceId],outputDelays);
			//we output the speakers gains to the dedicated control bus
			Out.kr(~controlBussesSpatGains[sourceId],outputGains);

			//we output the subs delays to the dedicated control bus
			Out.kr(~controlBussesSpatSubsDelayTimes[sourceId],outputSubsDelays);
			//we output the subs gains to the dedicated control bus
			Out.kr(~controlBussesSpatSubsGains[sourceId],outputSubsGains);

			//we also output a distance attenuation factor for the volume of the input audio
			center = ~speakersCentroid;
			maxRadius = ~speakersMaxRadius;
			distToCenter = ~distance.value(sourcePos,center);
			alpha = 0.04;
			q = 0.2;
			p = 1 + (distToCenter / maxRadius).pow(q);


			distanceAttenuationFactor = 1 / ( 1 + (alpha * ( distToCenter / maxRadius).pow(p)));

			Out.kr(~controlBussesSourcesDistanceAttenuation[sourceId],distanceAttenuationFactor);

		}).add;

	});

	s.sync;

	" ok.".postln;

	"[INIT] adding sources gain processing synth definitions...".post;

	//Then, we make a SynthDef that will get the audio input for a source, get the speakers gains from the control busses,and output the multiplied audio signals for each speaker, with the distance based delay;
	(1..~numSources).do({

		arg sourceIndex;
		SynthDef.new(("inputAudioProcessingSource"++sourceIndex).asSymbol,{
			var sourceId, speakersGains, speakersDelays, subsGains, subsDelays, audioInput, outputSignals, outputSignalsWet, outputSubsSignals, outputSubsSignalsWet, i, j, attenuationFactor, reverbDryWet;

			sourceId = ("source"++sourceIndex).asSymbol;

			speakersGains = In.kr(~controlBussesSpatGains[sourceId],~numSpeakers);
			speakersDelays = In.kr(~controlBussesSpatDelayTimes[sourceId],~numSpeakers);

			subsGains = In.kr(~controlBussesSpatSubsGains[sourceId],~numSubs);
			subsDelays = In.kr(~controlBussesSpatSubsDelayTimes[sourceId],~numSubs);

			reverbDryWet = In.kr(~controlBussesInputs[sourceId],~numSourceParameters)[6];

			audioInput = SoundIn.ar(sourceIndex - 1);
			attenuationFactor = In.kr(~controlBussesSourcesDistanceAttenuation[sourceId],1);

			//sats
			outputSignals = List.new;
			outputSignalsWet = List.new;
			i = 0;
			speakersGains.do({
				arg spkrGain;
				outputSignals.add(
					DelayC.ar(in: spkrGain * audioInput * attenuationFactor, maxdelaytime: 3.0, delaytime: (speakersDelays[i])**2);
				);
				outputSignalsWet.add(outputSignals[i] * reverbDryWet);
				i = i + 1;
			});

			//subs
			outputSubsSignals = List.new;
			outputSubsSignalsWet = List.new;
			j = 0;
			subsGains.do({
				arg spkrGain;
				outputSubsSignals.add(
					DelayC.ar(in: spkrGain * audioInput * attenuationFactor, maxdelaytime: 3.0, delaytime: (subsDelays[j])**2);
				);
				outputSubsSignalsWet.add(outputSubsSignals[j] * reverbDryWet);
				j = j + 1;
			});

			Out.ar(~audioBussesSpeakersDry,outputSignals);
			Out.ar(~audioBussesSpeakersPreFX,outputSignalsWet);

			Out.ar(~audioBussesSubsDry,outputSubsSignals);
			Out.ar(~audioBussesSubsPreFX,outputSubsSignalsWet);

		}).add;

	});

	s.sync;

	" ok.".postln;

	"[INIT] adding multichannel reverb FX synth definitions...".post;

	//MULTICHANNEL REVERB - from https://github.com/yotamorimoto/sclab/blob/main/nchannel_verb.scd
	//only applied on SATS at the moment
	n = ~numSpeakers;
	SynthDef(\reverbFX, {
		//arg decay=1, feedback=0.3;
		var signals, fbk, reverbParamsInputs, decay=0.5, feedback=0.5;

		reverbParamsInputs = In.kr(~controlBussesReverb,2);
		decay = reverbParamsInputs[0];
		feedback = reverbParamsInputs[1];

		signals = In.ar(~audioBussesSpeakersPreFX, n);
		signals = OnePole.ar(signals, 0.72);
		signals = AllpassC.ar(signals, 0.3, LFNoise1.kr(1).range(0.3,0.29), 3);

		fbk = LocalIn.ar(n);
		(n > 1).if({ fbk = fbk.scramble });
		fbk = OnePole.ar(fbk, 0.2);
		fbk = fbk + signals;

		7.do { fbk = AllpassN.ar(fbk, 0.05, {0.050.rand}!n, decay) };

		LocalOut.ar(fbk * feedback);

		Out.ar(~audioBussesSpeakersPostFX, fbk);

	}).add;

	s.sync;

	" ok.".postln;

	//TO DO: put gain processing in a synth before filter processing
	"[INIT] adding filter FX synth definitions...".post;

	SynthDef(\filterFX,{
		var inputSigsWet, inputSigsDry, inputSigsSubsDry, inputSignals, inputSubsSignals, outputSignals, outputSubsSignals, i, j, systemGain = 1.0, satsGains, subsGains, satsFilterParams, subsFilterParams;

		inputSigsDry = In.ar(~audioBussesSpeakersDry,~numSpeakers);
		inputSigsWet = In.ar(~audioBussesSpeakersPostFX,~numSpeakers);
		inputSigsSubsDry = In.ar(~audioBussesSubsDry,~numSubs);

		inputSignals = inputSigsDry + inputSigsWet;
		inputSubsSignals = inputSigsSubsDry;

		systemGain = In.kr(~controlBussesSystemGain,1);
		satsGains = In.kr(~controlBussesSatGains,~numSpeakers);
		subsGains = In.kr(~controlBussesSubGains,~numSubs);

		satsFilterParams = In.kr(~controlBussesSatFilter,2);
		subsFilterParams = In.kr(~controlBussesSubFilter,2);

		//add speakers gain (sats, system)

		//sats
		outputSignals = List.new;
		i = 0;
		inputSignals.do({
			arg signal;
			var speakerId, filteredSignal = RHPF.ar(signal,freq: satsFilterParams[0], rq: satsFilterParams[1]);
			outputSignals.add(filteredSignal * satsGains[i] * systemGain);

			speakerId = ("sat"++(i+1)).asSymbol;
			Out.ar(~audioBussesSpeakersEQ[speakerId],filteredSignal * satsGains[i] * systemGain);

			i = i + 1;
		});
		//subs
		outputSubsSignals = List.new;
		j = 0;
		inputSubsSignals.do({
			arg signal;
			var subId, filteredSignal = RLPF.ar(signal,freq: subsFilterParams[0], rq: subsFilterParams[1]);
			outputSubsSignals.add(filteredSignal * subsGains[j] * systemGain);

			subId = ("sub"++(j+1)).asSymbol;
			Out.ar(~audioBussesSubsEQ[subId],filteredSignal * subsGains[j] * systemGain);

			j = j + 1;
		});

		SendPeakRMS.ar(outputSignals, replyRate: 20.0, peakLag: 3, cmdName: '/sats/levels');

		//Out.ar(~audioBussesSpeakersEQ,outputSignals); //sats
		//Out.ar(~numSpeakers,outputSubsSignals); //subs

	}).add;

	s.sync;

	" ok.".postln;

	"[INIT] adding sats EQ FX synth definitions...".post;

	//SATS

	(1..~numSpeakers).do({
		arg i;
		var speakerId = ("sat"++i).asSymbol;

		SynthDef(
			("paramEQ-"++speakerId).asSymbol,
			{
				var inputSignal, outputSignal, signal, eqParams, eq_active, lshlf_active, lshlf_freq, lshlf_gain, lshlf_rs, pk1_active, pk1_freq, pk1_gain, pk1_rq, pk2_active, pk2_freq, pk2_gain, pk2_rq, pk3_active, pk3_freq, pk3_gain, pk3_rq, hshlf_active, hshlf_freq, hshlf_gain, hshlf_rs;

				eqParams = In.kr(~controlBussesSatEQ[speakerId],~numEQParameters);

				eq_active = eqParams[0];

				lshlf_active = eqParams[1];
				lshlf_freq = eqParams[2];
				lshlf_gain = eqParams[3];
				lshlf_rs = eqParams[4];

				pk1_active = eqParams[5];
				pk1_freq = eqParams[6];
				pk1_gain = eqParams[7];
				pk1_rq = eqParams[8];

				pk2_active = eqParams[9];
				pk2_freq = eqParams[10];
				pk2_gain = eqParams[11];
				pk2_rq = eqParams[12];

				pk3_active = eqParams[13];
				pk3_freq = eqParams[14];
				pk3_gain = eqParams[15];
				pk3_rq = eqParams[16];

				hshlf_active = eqParams[17];
				hshlf_freq = eqParams[18];
				hshlf_gain = eqParams[19];
				hshlf_rs = eqParams[20];

				inputSignal = In.ar(~audioBussesSpeakersEQ[speakerId],1);

				//low shelf
				signal = BLowShelf.ar(inputSignal,
					freq: lshlf_freq,
					rs: lshlf_rs,
					db: eq_active * lshlf_active * lshlf_gain;
				);

				//peak 1
				signal = BPeakEQ.ar(signal,
					freq: pk1_freq,
					rq: pk1_rq,
					db: eq_active * pk1_active * pk1_gain;
				);

				//peak 2
				signal = BPeakEQ.ar(signal,
					freq: pk2_freq,
					rq: pk2_rq,
					db: eq_active * pk2_active * pk2_gain;
				);

				//peak 3
				signal = BPeakEQ.ar(signal,
					freq: pk3_freq,
					rq: pk3_rq,
					db: eq_active * pk3_active * pk3_gain;
				);

				//high shelf
				outputSignal = BHiShelf.ar(signal,
					freq: hshlf_freq,
					rs: hshlf_rs,
					db: eq_active * hshlf_active * hshlf_gain;
				);

				Out.ar(i-1,outputSignal);

			}
		).add;
	});

	s.sync;

	" ok.".postln;

	"[INIT] adding subs EQ FX synth definitions...".post;


	//SUBS
	(1..~numSubs).do({
		arg i;
		var subId = ("sub"++i).asSymbol;

		SynthDef(
			("paramEQ-"++subId).asSymbol,
			{
				var inputSignal, outputSignal, signal, eqParams, eq_active, lshlf_active, lshlf_freq, lshlf_gain, lshlf_rs, pk1_active, pk1_freq, pk1_gain, pk1_rq, pk2_active, pk2_freq, pk2_gain, pk2_rq, pk3_active, pk3_freq, pk3_gain, pk3_rq, hshlf_active, hshlf_freq, hshlf_gain, hshlf_rs;

				eqParams = In.kr(~controlBussesSubEQ[subId],~numEQParameters);

				eq_active = eqParams[0];

				lshlf_active = eqParams[1];
				lshlf_freq = eqParams[2];
				lshlf_gain = eqParams[3];
				lshlf_rs = eqParams[4];

				pk1_active = eqParams[5];
				pk1_freq = eqParams[6];
				pk1_gain = eqParams[7];
				pk1_rq = eqParams[8];

				pk2_active = eqParams[9];
				pk2_freq = eqParams[10];
				pk2_gain = eqParams[11];
				pk2_rq = eqParams[12];

				pk3_active = eqParams[13];
				pk3_freq = eqParams[14];
				pk3_gain = eqParams[15];
				pk3_rq = eqParams[16];

				hshlf_active = eqParams[17];
				hshlf_freq = eqParams[18];
				hshlf_gain = eqParams[19];
				hshlf_rs = eqParams[20];

				inputSignal = In.ar(~audioBussesSubsEQ[subId],1);

				//low shelf
				signal = BLowShelf.ar(inputSignal,
					freq: lshlf_freq,
					rs: lshlf_rs,
					db: eq_active * lshlf_active * lshlf_gain;
				);

				//peak 1
				signal = BPeakEQ.ar(signal,
					freq: pk1_freq,
					rq: pk1_rq,
					db: eq_active * pk1_active * pk1_gain;
				);

				//peak 2
				signal = BPeakEQ.ar(signal,
					freq: pk2_freq,
					rq: pk2_rq,
					db: eq_active * pk2_active * pk2_gain;
				);

				//peak 3
				signal = BPeakEQ.ar(signal,
					freq: pk3_freq,
					rq: pk3_rq,
					db: eq_active * pk3_active * pk3_gain;
				);

				//high shelf
				outputSignal = BHiShelf.ar(signal,
					freq: hshlf_freq,
					rs: hshlf_rs,
					db: eq_active * hshlf_active * hshlf_gain;
				);

				Out.ar(~numSpeakers + i-1,outputSignal);

			}
		).add;
	});

	s.sync;

	" ok.".postln;

	//==================== GROUPS ====================

	"[INIT] creating synth groups...".post;

	~sourcesSpatPannersGroup = Group.new(s.defaultGroup, \addToTail);
	~sourcesGainProcessingGroup = Group.new(s.defaultGroup, \addToTail);
	~fxGroup = Group.new(s.defaultGroup, \addToTail);
	~reverbGroup = Group.new(~fxGroup, \addToTail);
	~filterGroup = Group.new(~fxGroup, \addToTail);
	~eqGroup = Group.new(~fxGroup, \addToTail);

	s.sync;

	" ok.".postln;

	//==================== CREATING SYNTHS ====================

	"[INIT] creating synths - source panners...".post;

	(1..~numSources).do({
		arg sourceIndex;
		Synth.tail(~sourcesSpatPannersGroup, ("spatPannerSource"++sourceIndex).asSymbol);
	});

	s.sync;

	" ok.".postln;

	"[INIT] creating synths - source gain processing...".post;

	(1..~numSources).do({
		arg sourceIndex;
		Synth.tail(~sourcesGainProcessingGroup, ("inputAudioProcessingSource"++sourceIndex).asSymbol);
	});

	s.sync;

	" ok.".postln;

	"[INIT] creating synths - reverb...".post;

	~reverbSynth = Synth.tail(~reverbGroup,\reverbFX);

	s.sync;

	" ok.".postln;

	"[INIT] creating synths - filter...".post;

	~filterSynth = Synth.tail(~filterGroup,\filterFX);

	s.sync;

	" ok.".postln;

	"[INIT] creating synths - EQs...".post;

	(1..~numSpeakers).do({
		arg i;
		var speakerId = ("sat"++i).asSymbol;
		Synth.tail(~eqGroup, ("paramEQ-"++speakerId).asSymbol);
	});

	(1..~numSubs).do({
		arg i;
		var subId = ("sub"++i).asSymbol;
		Synth.tail(~eqGroup, ("paramEQ-"++subId).asSymbol);
	});

	s.sync;

	" ok.".postln;

	//==================== OSC INPUT SETUP ====================

	"[INIT] creating OSC inputs receivers...".post;

	//OSC - Sources parameters
	(1..~numSources).do({
		arg i;
		var sourceId = ("source"++i).asSymbol;
		OSCdef(
			("source"++i++"-OSCreceiver").asSymbol, //receiver name
			{                                            //function called when valid message is received
				arg msg;
				var ackArray = Array.fill(~numSourceParameters,0);
				//msg.postln;
				(1..~numSourceParameters).do{
					arg i;
					~controlBussesInputs[sourceId].setAt(i-1,msg[i]);
					ackArray[i-1] = msg[i];
				};
				~oscSendNetAddr.sendMsg(("/akMserver/ack/source"++i).asSymbol,*ackArray);
			},
			("source"++i).asSymbol,             //OSC address
			NetAddr("127.0.0.1"),
			~oscReceivePort
		);
	});

	//OSC - Reverb
	OSCdef(
		("reverb-OSCreceiver").asSymbol, //receiver name
		{
			arg msg;
			~controlBussesReverb.setAt(0,msg[1]);
			~controlBussesReverb.setAt(1,msg[2]);
		},
		'/reverb',
		NetAddr("127.0.0.1"),
		~oscReceivePort
	);

	//OSC - System Gain
	OSCdef(
		("systemGain-OSCreceiver").asSymbol, //receiver name
		{
			arg msg;
			~controlBussesSystemGain.setAt(0,~dB_to_factor.value(msg[1]));
			~oscSendNetAddr.sendMsg("/akMserver/ack/system/gain",msg[1]);
		},
		'/system/gain',
		NetAddr("127.0.0.1"),
		~oscReceivePort
	);

	//OSC - Satellites Filter
	OSCdef(
		("satsFilter-OSCreceiver").asSymbol, //receiver name
		{
			arg msg;
			~controlBussesSatFilter.setAt(0,msg[1]);
			~controlBussesSatFilter.setAt(1,msg[2]);
		},
		'/sats/filter',
		NetAddr("127.0.0.1"),
		~oscReceivePort
	);

	//OSC - Subs Filter
	OSCdef(
		("subsFilter-OSCreceiver").asSymbol, //receiver name
		{
			arg msg;
			~controlBussesSubFilter.setAt(0,msg[1]);
			~controlBussesSubFilter.setAt(1,msg[2]);
		},
		'/subs/filter',
		NetAddr("127.0.0.1"),
		~oscReceivePort
	);

	//OSC - Satellites Gains
	(1..~numSpeakers).do({
		arg i;
		OSCdef(
			("sat"++i++"-gain-OSCreceiver").asSymbol, //receiver name
			{
				arg msg;
				~controlBussesSatGains.setAt(i-1,~dB_to_factor.value(msg[1]));
			},
			("sat"++i++"/gain").asSymbol,
			NetAddr("127.0.0.1"),
			~oscReceivePort
		);

	});

	//OSC - Subs Gains
	(1..~numSubs).do({
		arg i;
		OSCdef(
			("sub"++i++"-gain-OSCreceiver").asSymbol, //receiver name
			{
				arg msg;
				~controlBussesSubGains.setAt(i-1,~dB_to_factor.value(msg[1]));
			},
			("sub"++i++"/gain").asSymbol,
			NetAddr("127.0.0.1"),
			~oscReceivePort
		);

	});

	//OSC - Satellites EQ
	(1..~numSpeakers).do({
		arg i;
		var speakerId = ("sat"++i).asSymbol;
		OSCdef(
			("sat"++i++"-eq-OSCreceiver").asSymbol, //receiver name
			{
				arg msg;
				(1..~numEQParameters).do{
					arg j;
					~controlBussesSatEQ[speakerId].setAt(j-1,msg[j]);
				};
			},
			("sat"++i++"/eq").asSymbol,
			NetAddr("127.0.0.1"),
			~oscReceivePort
		);

	});


	//OSC - Sub EQ
	(1..~numSubs).do({
		arg i;
		var subId = ("sub"++i).asSymbol;
		OSCdef(
			("sub"++i++"-eq-OSCreceiver").asSymbol, //receiver name
			{
				arg msg;
				(1..~numEQParameters).do{
					arg j;
					~controlBussesSubEQ[subId].setAt(j-1,msg[j]);
				};
			},
			("sub"++i++"/eq").asSymbol,
			NetAddr("127.0.0.1"),
			~oscReceivePort
		);

	});

	// QUIT SERVER
	OSCdef(
		("serverQuit-OSCreceiver").asSymbol, //receiver name
		{
			arg msg;
			s.quit();
		},
		("quit").asSymbol,
		NetAddr("127.0.0.1"),
		~oscReceivePort
		);

	s.sync;

	" ok.".postln;

	//==================== OSC OUTPUT SETUP ====================

	"[INIT] creating OSC outputs senders...".post;

	//making a server heartbeat

	~oscHeartbeatRoutine = Routine({
		loop {
			if (
				s.serverRunning,
				{
					~oscSendNetAddr.sendMsg("/akMserver/status/heartbeat",1);
				},
				{}
			);

			1.wait;
		}

	});

	~oscHeartbeatRoutine.play;

	s.sync;

	" ok.".postln;

	"--------------------------------------------------------".postln;
	"AKM SPAT SERVER READY".postln;
	"--------------------------------------------------------".postln;

});


